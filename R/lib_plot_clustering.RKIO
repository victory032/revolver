revolver_plot_cluster = function(
  x,
  hc.method = "ward",
  split.method = "cutreeHybrid",
  dendogram.type = 'rectangle',
  cutoff.features_annotation = 3,
  min.group.size = 2,
  plot.clusters = TRUE,
  plot.groups = TRUE,
  file = 'REVOLVER-clustering.pdf',
  ...
)
{
  if(is.null(x$cluster)) stop('Did you compute evo?')

  distance = x$cluster$distances
  params = x$cluster$distances.params
  dist.obj = x$cluster$dist.obj

  hc = x$cluster$hc
  dendogram =  x$cluster$dendogram
  dendextend::labels_cex(dendogram) = .5 # decrease cex if there are many elements

  ############### Optimal number of clusters with dynamicTreeCut
  cat(cyan('\n[dynamicTreeCut/dendextend] Cutting dendogram\n'))

  clusters = split_dendogram(
    dendogram, hc, distance,
    split.method, min.group = min.group.size, do.plot = FALSE)

  x$cluster$clusters = clusters$clusters
  x$cluster$k = clusters$k
  x$cluster$split.method = split.method
  x$cluster$labels.colors = clusters$labels.colors

  cat(cyan('\tmethod :'), split.method, '-', ifelse(split.method != 'static', 'from dynamicTreeCut', 'via silhouette scoring'), '\n')
  cat(cyan('\t   |g| :'), min.group.size, '\n')
  cat(cyan('\t     k :'), clusters$k, '\n')

  if(plot.clusters)
  {
    pdf('Dendogram.pdf', width = 10, height = 10)
    plot_dendogram(
      hc,
      dendogram,
      x$clusters$clusters,
      plot.type = dendogram.type,
      main = paste("REVOLVER clustering of", x$annotation),
      sub = paste(
        'Agnes clustering (', hc.method, ' method; AC=', round(hc$ac, 3) ,') \nand ',
        split.method,' as dendogram cutting method', sep =''),
      colors = x$cluster$labels.colors
    )

    # bannerplot associated to the custering
    cluster::bannerplot(hc, main = 'Banner plot', col = c('gainsboro', 'steelblue'))
    dev.off()
  }

  #################### Features plot -- the most important one?
  if(plot.clusters)
    revolver_featurePlot(x, width = length(x$patients), height = length(x$patients), file = 'Clonal-table.pdf')

  # ##############################
  # #### Compare against other clusterings via tanglegram
  # ##############################
  features = revolver.featureMatrix(x)

  if(plot.clusters)
  {
  cat(cyan('[tanglegram] Comparison against other clusterings: '))

  # Occurrence of mutations (binarized from avg. CCFs in features$occurrences)
  occurrences.binarized = features$occurrences
  occurrences.binarized[occurrences.binarized > 0] = 1

  occurrences.binarized = as.matrix(occurrences.binarized)
  hc2 = cluster::agnes(stats::dist(occurrences.binarized), method = hc.method)
  dendogram2 = stats::as.dendrogram(hc2)
  dendextend::labels_cex(dendogram2) = 0.5

  # Plotting comparative clusterings via tanglegrams
  pdf('tanglegram.pdf', width = 10, height = 10)
  dend_list <- dendextend::dendlist(dendogram, dendogram2)

  dendextend::tanglegram(dendogram, dendogram2,
               highlight_distinct_edges = FALSE, # Turn-off dashed lines
               common_subtrees_color_lines = TRUE, # Turn-off line colors
               common_subtrees_color_branches = TRUE, # Color common branches
               cex_main = 1,
               main = paste("Binary occurrences"),
               sub = paste("entanglement =", round(dendextend::entanglement(dend_list), 4))
  )

  plot_dendogram(
      hc2,
      dendogram2,
      x$cluster$clusters,
      plot.type = dendogram.type,
      main = paste("Dendogram of Binary occurrences"),
      sub = '',
      colors = x$cluster$labels.colors
  )

  hc3 = cluster::agnes(dist(features$occurrences.clonal.subclonal), method = hc.method)
  dendogram3 = stats::as.dendrogram(hc3)
  dendextend::labels_cex(dendogram3) = 0.5
  dend_list = dendextend::dendlist(dendogram, dendogram3)

  dendextend::tanglegram(dendogram, dendogram3,
               highlight_distinct_edges = FALSE, # Turn-off dashed lines
               common_subtrees_color_lines = TRUE, # Turn-off line colors
               common_subtrees_color_branches = TRUE, # Color common branches
               cex_main = 1,
               main = paste("Clonal/Subclonal occurrences"),
               sub = paste("entanglement =", round(dendextend::entanglement(dend_list), 4))
  )

  plot_dendogram(
      hc3,
      dendogram3,
      x$cluster$clusters,
      plot.type = dendogram.type,
      main = paste("Dendogram of Clonal/Subclonal"),
      sub = '',
      colors = x$cluster$labels.colors
  )

    dev.off()
    jamPDF(in.files = 'tanglegram.pdf', out.file = 'tanglegram.pdf', layout = '2x2')
    cat(green('DONE\n'))
  }


  ##############################
  # Plotting the evolutionary distance
  # # Annotate each sample with the cluster ID
  annotations.samples = data.frame(cluster = clusters$clusters)
  annotations.samples = annotations.samples[rownames(features$occurrences), , drop = FALSE]

  if(plot.clusters)
  {

    cat(cyan('Plotting the evolutionary distance: '))

    pheatmap::pheatmap(
      distance,
      main = paste("Evolutionary Distance \n ",
                   paste('GL:', params['use.GL'], '\n',
                         'Transitive closure:', params['transitive.closure'])),
      cluster_rows = as.hclust(hc),
      cluster_cols = as.hclust(hc),
      color = scols(1:100, "YlOrRd"),
      border_color = NA,
      show_rownames = T,
      show_colnames = T,
      # treeheight_row = max(hc$height)/3,
      # treeheight_col = max(hc$height)/3,
      annotation_row = annotations.samples[, 'cluster', drop = FALSE],
      annotation_col = annotations.samples[, 'cluster', drop = FALSE],
      annotation_colors = list(cluster = x$cluster$labels.colors),
      fontsize_row = 3,
      fontsize_col = 3,
      # treeheight_col = 70,
      # treeheight_row = 70,
      cellwidth = 4,
      cellheight = 4,
      # width = 20,
      # height = 20,
      file = paste('Edistance.pdf')
    )
    jamPDF(in.files = c("Dendogram.pdf", 'Edistance.pdf'), out.file = 'Dendogram.pdf', layout = '3x1')
    cat(green('DONE\n'))
  }


  if(plot.groups)
  {
    cat(cyan('Plotting fit models dividided by group.\n'))

    groups = split(annotations.samples, f = annotations.samples$cluster)
    transfer = x$cluster$transfer

    files = sapply(
      1:length(groups),
      function(w){

        fname = paste('Cluster', names(groups)[w], file, sep = '-')

        plot(x, patients = rownames(groups[[w]]),
             out.file = fname, plot.stat = FALSE, layout = '1x1', palette = 'Dark2')

        tr = Reduce(rbind, transfer[rownames(groups[[w]])])
        tr.ids = apply(tr, 1, paste, collapse = '~')
        tr.ids = table(tr.ids)
        tr.ids = as.data.frame(tr.ids)
        rownames(tr.ids) = tr.ids$tr.ids

        tr = (unique(tr))
        rownames(tr) = apply(tr, 1, paste, collapse = '~')

        tr = cbind(tr, tr.ids[rownames(tr), ])
        rownames(tr) = tr$tr.ids =  NULL
        tr$count = tr$Freq
        tr$Freq = tr$Freq / nrow(groups[[w]])
        tr = tr[order(tr$Freq, decreasing = T), ]
        tr = tr[tr$count > 1, ]

        w = min(10, nrow(tr))
        if(w == 0) return('')

        cat(cyan('\n Counts > 1 table\n'))
        print(tr[1:w, ])

        pdf("data_output.pdf", height = nrow(tr), width = 8.5)

        gridExtra::grid.arrange(gridExtra::tableGrob(tr))
        dev.off()

        jamPDF(
          in.files = c("data_output.pdf", fname),
          out.file = fname,
          layout = '1x1'
        )

        fname
    })

    # jamPDF(in.files = files, out.file = 'groups.pdf', layout = '1x1')
  }

  # Plot consensus model for each group
  if(plot.clusters)
  {
    groups = x$cluster$clusters
    for(g in unique(groups))
      revolver_plotrj_consensus(
        x,
        patients = names(groups[groups == g]), min.cutoff = 3, ML = TRUE, file = paste('Con', g, '.pdf', sep = ''),
        annotation = paste("Cluster", g),
        col.annotation = x$cluster$labels.colors[as.character(g)])

    revolver_plotrj_consensus(x, min.cutoff = 3, ML = TRUE, file = 'ConsensusModel.pdf', width = 10, height = 10, annotation = paste("All cohort"))

    jamPDF(
      in.files = c("ConsensusModel.pdf", paste('Con', unique(groups), '.pdf', sep = '')),
      out.file = 'Consensus.pdf',
      layout = '1x1'
      # page = 'a4'
    )


    cat(cyan('Assembling final PDF:'), yellow(file))
    #
    jamPDF(
      in.files = c('Clonal-table.pdf', 'Dendogram.pdf', 'tanglegram.pdf'),
      out.file = file,
      # page = 'a4',
      layout = '1x1'
    )
  }

  # cat(cyan('* jamming PDFs'))
  # jamPDF(in.files = c('mainClustering2.pdf', 'Edistance.pdf'), out.file = 'mainClustering2.pdf', layout = '2x2')
  # jamPDF(c('mainClustering.pdf', 'mainClustering2.pdf'), out.file = 'mainClustering.pdf', layout = '2x1')
  # jamPDF(in.files = c('cutreeDynamic.pdf', 'dendextend.pdf'), out.file = 'dendextend.pdf', layout = '1x2')
  #
  #
  # jamPDF(
  #   in.files = c('mainClustering.pdf','Clonal-table.pdf',  'dendextend.pdf',  'tanglegram.pdf', 'AC.pdf' ),
  #   out.file = file,
  #   layout = '1x1'
  # )
  # cat(green(' DONE\n'))


  return(x)
}



########### Plot ML estimates for the information transfer
revolver_plotrj_consensus = function(x, annotation = NA, col.annotation = 'white',
                                     patients = x$patients, min.cutoff = 3, ML = TRUE,
                                     file = NA, ...)
{
  if(is.null(x$fit)) stop('Fit a model first, stopping.')

  features = revolver.featureMatrix(x, patients = patients)
  inf.transf = features$consensus.explosion

  if(min.cutoff >= max(inf.transf$count)) min.cutoff = max(inf.transf$count) - 1
  inf.transf = inf.transf[inf.transf$count > min.cutoff, , drop = FALSE]

  if(ML) {
    inf.transf = split(inf.transf, f = inf.transf$to)
    inf.transf = lapply(inf.transf, function(w) {
       w[which(w$count == max(w$count)), , drop = FALSE]
    })
    inf.transf = Reduce(rbind, inf.transf)
  }

  adj_matrix = DataFrameToMatrix(inf.transf)
  occ.table = clonal.subclonal.table(x)

  # Augment labels
  lbify = function(w){
    if(w == 'GL') return(w)
    else paste(w, ' [', occ.table[w, 'Clonal'], ', ', occ.table[w, 'SubClonal']  ,']', sep = '')
  }

  edgeify = function(w){
    w[1] = strsplit(w[1], split = ' ')[[1]][1]
    w[2] = strsplit(w[2], split = ' ')[[1]][1]

    inf.transf[inf.transf$from == w[1] & inf.transf$to == w[2], 'count']
  }

  colnames(adj_matrix) = sapply(colnames(adj_matrix), lbify)
  rownames(adj_matrix) = sapply(rownames(adj_matrix), lbify)

  G = igraph::graph_from_adjacency_matrix(adj_matrix)

  # colors for the nodes...
  igraph::V(G)$color  = "white"

  edLabel = apply(igraph::as_edgelist(G), 1, edgeify)
  edLabel = as.matrix(edLabel, ncol = 1)

  # we work on the layout -- tree if it has GL
  lay = NULL
  if('GL' %in%  igraph::V(G)$name) {
    lay = igraph::layout.reingold.tilford(G, root = 'GL',  mode = 'all')
    rownames(lay) =  igraph::V(G)$name
  }

  # TS = wrapTS(adj_matrix)
  # for(node in TS) lay = fixLayer(node, lay, offset = 2)

  if(!is.na(file)) pdf(file, ...)
  plot(G,
       vertex.frame.color = 'white',
       edge.arrow.size = .5,
       edge.color = 'black',
       edge.label = edLabel,
       layout = lay)
  title(main = 'Information transfer (consensus)')

  legend('topleft',  title = 'Parameters',
         legend = as.expression(
           c(
             bquote(italic(n) == ~ .(length(patients)) ~ '(patients)' ),
             bquote(rho == ~ .(min.cutoff) ~ '(min. freq.)'),
             bquote(ML == ~ .(as.character(ML)) ~ '(MLE)')
           )),
         pch = 19,
         col = c('forestgreen'),
         bg = add.alpha('forestgreen', .3),
         box.col = 'white'
  )

  legend('topright', legend = annotation, bg = add.alpha(col.annotation, .7), pch = 19,  box.col = 'white')

  if(!is.na(file)) dev.off()
}



#################### Features plot -- the most important one for clustering etc.
revolver_featurePlot = function(x, cutoff.features_annotation = 2,
                                file = NA, width = 20, height = 15, device = 'quartz',
                                annotate.alterations = NA, clinical.covariates = NA)
{

  if(is.null(x$fit)) stop('Fit a model first, stopping.')
  if(is.null(x$cluster)) stop('Cluster your cohort first, stopping.')

  # Obvious things that we need for this plot
  clusters = x$cluster
  features = revolver.featureMatrix(x)
  use.GL = x$cluster$distances.params['use.GL']
  hc = as.hclust(x$cluster$hc)
  hc.method = x$cluster$hc$method
  labels.colors = x$cluster$labels.colors

  if(!all(is.na(annotate.alterations))) {
    features$occurrences = features$occurrences[, annotate.alterations, drop = FALSE]
  }
  features$occurrences = features$occurrences[, names(sort(colSums(features$occurrences), decreasing = T))]

  # Annotate each sample with the cluster ID
  annotations.samples = data.frame(cluster = clusters$clusters)
  annotations.samples = annotations.samples[rownames(features$occurrences), , drop = FALSE]

  clusters = split(annotations.samples, f = annotations.samples$cluster)
  transfer = x$cluster$transfer

  # Featured as edges: get all edges in at least cutoff.features_annotation patients; if required remove GL
  which.features = features$consensus.explosion[features$consensus.explosion$count > cutoff.features_annotation, , drop  = F]

  if(!all(is.na(annotate.alterations))) {
    annotate.alterations = c(annotate.alterations, 'GL') # We add germline

    which.features = which.features[
      which.features$from %in% annotate.alterations &
        which.features$to %in% annotate.alterations, , drop = FALSE]
  }

  if(!use.GL) which.features = which.features[which.features$from != 'GL', , drop = FALSE]
  cat(cyan('Features that will be annotated [ use.GL ='), use.GL, cyan(']'), '\n')
  print(which.features)

  edges.annotation = features$edges.explosion[, which.features$edge, drop = FALSE]
  colnames(edges.annotation) = gsub(pattern = '~', ' \u2192 ', colnames(edges.annotation))

  annotations.samples = cbind(annotations.samples, edges.annotation)

  if(!all(is.na(clinical.covariates))) annotations.samples = cbind(annotations.samples, clinical.covariates)

  # rownames(clinical.covariates) %in% rownames(annotations.samples)

  colors.edges.annotation = sapply(
    colnames(edges.annotation),
    function(w) list(c('0' = 'gainsboro', '1' = 'darkgray')))

  numbers.matrix = features$clonal.status[, colnames(features$occurrences), drop = FALSE]
  numbers.matrix[numbers.matrix == 1] = '\u25a0'
  numbers.matrix[numbers.matrix == 0] = ''


  # device
  if(!is.na(file)) dodev(width = width, height = height, device = device)

  setHook("grid.newpage", function() grid::pushViewport(grid::viewport(x=1,y=1,width=0.9, height=0.9, name="vp", just=c("right","top"))), action="prepend")


  pheatmap::pheatmap(features$occurrences,
                     cluster_cols = F,
                     cluster_rows = as.hclust(hc),
                     # clustering_distance_rows = dist.obj,
                     clustering_method = ifelse(hc.method == 'ward', 'ward.D2', hc.method),
                     color = c("white", scols(1:9, "Blues")),
                     breaks = seq(0, 1.1, 0.1),
                     # main = "Input data",
                     annotation_row = annotations.samples,
                     display_numbers = numbers.matrix,
                     number_color = 'orange',
                     # legend_breaks = unique(annotations.samples$cluster),
                     annotation_legend = FALSE,
                     # annotation_col = annotations.cols,
                     annotation_colors = append(list(cluster = labels.colors), colors.edges.annotation),
                     # cutree_rows = nGroups,
                     treeheight_row = max(hc$height)/1.5,
                     cellwidth = 10, cellheight = 12,
                     na_col = 'gainsboro',
                     legend = TRUE
                     )


  setHook("grid.newpage", NULL, "replace")

  params = paste('use.GL =', x$cluster$distances.params['use.GL'], '& transitive.closure =', x$cluster$distances.params['transitive.closure'])

  grid::grid.text(
    bquote(bold('Distance ')~italic(h)~' : '~.(params)~bold('  Clustering : ')~.(hc.method)~ ' / '~.(x$cluster$split.method)~' / k ='~.(x$cluster$k)~""),
    y=-0.07, gp=grid::gpar(fontsize=16))

  grid::grid.text(
    bquote(bold('REVOLVER Clusters : ')~.(x$annotation)),
    y=0.97, gp=grid::gpar(fontsize=16))

  grid::grid.text(
    bquote(bold('Left : ')~.('Evolutionary trajectories')),
    x=-0.07, rot=90, gp=grid::gpar(fontsize=16))

  grid::grid.text(
    bquote(bold('Right : ')~.('Input data (mean CCF value, \u25a0 is clonal)')),
    x=0.97, rot=270, gp=grid::gpar(fontsize=16))

  if(!is.na(file)) udodev(file = file)
}
